<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>UFO Sightings Explorer — USA Focus</title>
<script src="https://unpkg.com/vega@5"></script>
<script src="https://unpkg.com/vega-lite@5"></script>
<script src="https://unpkg.com/vega-embed@6"></script>
<style>
  body{margin:0;background:#0f172a;color:#e5e7eb;font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
  .container{max-width:1220px;margin:auto;padding:24px}
  h1{margin:0 0 8px}
  .grid{display:grid;grid-template-columns:1fr 1fr;gap:16px}
  .card{background:#0b1220;border:1px solid #1f2937;border-radius:14px;padding:12px}
  .card h2{margin:0 0 8px;display:flex;align-items:center;gap:8px}
  .badge{font-size:12px;color:#a3e635;background:#052e16;border:1px solid #14532d;border-radius:999px;padding:2px 8px}
  .badge.err{color:#fecaca;background:#3f1d1d;border:1px solid #7f1d1d}
  .viz{min-height:340px}
  @media (max-width:900px){.grid{grid-template-columns:1fr}}
</style>
</head>
<body>
<div class="container">
  <h1>UFO Sightings Explorer — USA Focus</h1>
  <p>This page auto-finds your CSVs in <code>/data</code> or the repo root, and shows a badge with what it loaded.</p>

  <div class="grid">
    <div class="card" style="grid-column:1/-1">
      <h2>US city hotspots (map) <span id="b-map" class="badge">checking…</span></h2>
      <div id="map" class="viz" style="min-height:420px"></div>
    </div>

    <div class="card" style="grid-column:1/-1">
  <h2>All sightings (binned heatmap) <span id="b-heat" class="badge">checking…</span></h2>
  <div id="heat" class="viz" style="min-height:420px"></div>
</div>


    <div class="card">
      <h2>Monthly trend (line+area) <span id="b-monthly" class="badge">checking…</span></h2>
      <div id="monthly" class="viz"></div>
    </div>

    <div class="card">
      <h2>Hourly rhythm (radial donut) <span id="b-hourly" class="badge">checking…</span></h2>
      <div id="hourly" class="viz"></div>
    </div>

    <div class="card">
      <h2>Top cities (bar) <span id="b-cities" class="badge">checking…</span></h2>
      <div id="cities" class="viz"></div>
    </div>

    <div class="card">
      <h2>Shapes (overall) <span id="b-shapes" class="badge">checking…</span></h2>
      <div id="shapes" class="viz"></div>
    </div>
  </div>
</div>

<script>
/* ---------- Paths & helpers ---------- */
const PATHS = {
  // MAP needs LAT/LON
  citiesLatLon: ["data/ufo_cities_latlon.csv","ufo_cities_latlon.csv"], // city,state,country,latitude,longitude,count (comma CSV)
  // Aggregates (semicolon CSV)
  cities:  ["data/ufo_cities.csv","ufo_cities.csv"],        // city;count
  monthly: ["data/ufo_monthly.csv","ufo_monthly.csv"],      // month;count
  shapes:  ["data/ufo_shape.csv","ufo_shape.csv"],          // shape;count
  hourly:  ["data/ufo_hourly.csv","ufo_hourly.csv"]         // hour;count
};

// Try multiple URLs (data/ then root), add cache-buster
async function fetchFirst(paths){
  let lastErr;
  for (const p of paths){
    const url = p + "?v=" + Date.now();
    try {
      const res = await fetch(url);
      if (!res.ok) throw new Error(`${res.status} ${res.statusText}`);
      const txt = await res.text();
      return {url:p, text:txt};
    } catch(e){ lastErr = e; }
  }
  throw lastErr || new Error("All paths failed");
}

// Parsers
function parseSemi(text){
  const lines = text.trim().split(/\r?\n/).filter(Boolean);
  if(lines.length<2) return [];
  const headers = lines[0].split(";").map(h=>h.trim());
  return lines.slice(1).map(line=>{
    const cells = line.split(";");
    const row = {};
    headers.forEach((h,i)=> row[h] = (cells[i]??"").trim());
    return row;
  });
}
function parseComma(text){
  const lines = text.trim().split(/\r?\n/).filter(Boolean);
  if(lines.length<2) return [];
  const headers = lines[0].split(",").map(h=>h.trim());
  return lines.slice(1).map(line=>{
    const cells = line.split(",");
    const row = {};
    headers.forEach((h,i)=> row[h] = (cells[i]??"").trim());
    return row;
  });
}

function setBadge(id, msg, ok=true){
  const el = document.getElementById(id);
  if(!el) return; el.textContent = msg; el.className = "badge" + (ok ? "" : " err");
}

// Extract YYYY-MM from almost any date string (e.g. 1990-01-01, 1/1/1990, 1990.01)
function ymKey(s){
  const m = String(s||"").match(/(\d{4}).*?(\d{1,2})/); // year + month
  if(!m) return null;
  const yyyy = m[1], mm = m[2].padStart(2,"0");
  return `${yyyy}-${mm}`;
}
</script>

<script>
// 1) MAP (needs ufo_cities_latlon.csv with commas)
async function renderMap(){
  // helpers
  function smartDeg(s){
    const t = String(s ?? "").trim();
    // try plain number (handles normal decimals and 40,123 -> 40.123)
    const direct = Number(t.replace(',', '.'));
    if (isFinite(direct)) return direct;
    // dotted thousands like 401.947.222 -> 40.1947222 (9 digits) or 7+ digits in general
    const neg = t.startsWith('-') ? -1 : 1;
    const digits = t.replace(/[^0-9]/g, '');
    if (!digits) return NaN;
    // scale to 7+ fractional digits
    const scale = Math.pow(10, Math.max(7, digits.length - 2));
    return neg * (Number(digits) / scale);
  }
  function pickIdx(headers, names){
    const L = headers.map(h=>h.toLowerCase());
    for(const n of names){
      const i = L.indexOf(n.toLowerCase());
      if(i >= 0) return i;
    }
    return -1;
  }

  try{
    // fetch from /data or root
    const paths = ["data/ufo_cities_latlon.csv","ufo_cities_latlon.csv"];
    let raw=null, src=null;
    for(const p of paths){
      const r = await fetch(p + "?v=" + Date.now());
      if(r.ok){ raw = await r.text(); src = p; break; }
    }
    if(!raw) throw new Error("ufo_cities_latlon.csv not found");

    // normalise delimiter: turn semicolons into commas, then split
    const text = raw.replace(/;/g, ",").trim();
    const lines = text.split(/\r?\n/).filter(Boolean);
    const headers = lines.shift().split(",").map(h=>h.trim());
    const iCity = pickIdx(headers, ["city"]);
    const iState = pickIdx(headers, ["state","region"]);
    const iLat   = pickIdx(headers, ["latitude","lat"]);
    const iLon   = pickIdx(headers, ["longitude","lon","lng","long"]);
    const iCnt   = pickIdx(headers, ["count","sightings","value","total"]);

    const values = lines.map(l=>{
      const c = l.split(",");
      const lat = smartDeg(c[iLat]);
      const lon = smartDeg(c[iLon]);
      const cnt = Number(String(c[iCnt] ?? "").replace(/[, ]/g,""));
      return {
        city: (c[iCity] ?? "").trim(),
        state:(c[iState] ?? "").trim(),
        lat, lon, count: cnt
      };
    }).filter(d => isFinite(d.lat)&&isFinite(d.lon)&&isFinite(d.count)
                   && d.lat>=-90 && d.lat<=90 && d.lon>=-180 && d.lon<=180);

    // update badge if you have it
    const badge = document.getElementById("b-map");
    if (badge){ badge.textContent = `loaded ${values.length} rows from ${src}`; badge.className = "badge"; }

    const spec = {
      $schema:'https://vega.github.io/schema/vega-lite/v5.json',
      width:1180, height:420,
      projection:{ type:'albersUsa' },
      layer:[
        {
          data:{ url:'https://vega.github.io/vega-datasets/data/us-10m.json',
                 format:{ type:'topojson', feature:'states' } },
          mark:{ type:'geoshape', fill:'#091120', stroke:'#1f2937' }
        },
        {
          data:{ values },
          mark:{ type:'circle', tooltip:true, opacity:0.9, stroke:'#0b1220', strokeWidth:0.6 },
          encoding:{
            longitude:{ field:'lon', type:'quantitative' },
            latitude:{ field:'lat', type:'quantitative' },
            size:{ field:'count', type:'quantitative', title:'Sightings',
                   scale:{ type:'sqrt', range:[10,1600] } },
            color:{ value:'#38bdf8' },
            tooltip:[
              {field:'city', title:'City'},
              {field:'state', title:'State'},
              {field:'count', type:'quantitative', title:'Reports'},
              {field:'lat', title:'lat'}, {field:'lon', title:'lon'}
            ]
          }
        }
      ],
      config:{ background:null }
    };
    vegaEmbed('#map', spec, {actions:false});
  }catch(e){
    console.error('Map load error:', e);
    const badge = document.getElementById('b-map');
    if (badge) { badge.textContent = 'failed to load'; badge.className = 'badge err'; }
  }
}

// Heatmap of ALL reports from scrubbed.csv (one row per sighting)
async function renderHeat(){
  // helper: convert dotted coords like "401.947.222" -> 40.1947222
  function smartDeg(s){
    const t = String(s ?? "").trim();
    const direct = Number(t.replace(',', '.'));
    if (isFinite(direct)) return direct;
    const neg = t.startsWith('-') ? -1 : 1;
    const digits = t.replace(/[^0-9]/g, '');
    if (!digits) return NaN;
    const scale = Math.pow(10, Math.max(7, digits.length - 2));
    return neg * (Number(digits) / scale);
  }

  try{
    // scrubbed.csv is at repo root. If you moved it to /data, change to "data/scrubbed.csv"
    const r = await fetch("scrubbed.csv?v=" + Date.now());
    if (!r.ok) throw new Error(r.status);
    const txt = (await r.text()).trim();

    const lines = txt.split(/\r?\n/);
    const hdr = lines.shift().split(",").map(h=>h.trim().toLowerCase());
    const idx = n => hdr.indexOf(n);

    // Prefer numeric lat/lon columns if you created them, else parse originals
    const iLatNum = idx("lat_num"), iLonNum = idx("lon_num");
    const iLat = iLatNum >= 0 ? iLatNum : idx("latitude");
    const iLon = iLonNum >= 0 ? iLonNum : idx("longitude");

    const pts = lines.map(l=>{
      const c = l.split(",");
      const lat = iLatNum>=0 ? Number(c[iLat]) : smartDeg(c[iLat]);
      const lon = iLonNum>=0 ? Number(c[iLon]) : smartDeg(c[iLon]);
      return {lat, lon};
    }).filter(d => isFinite(d.lat)&&isFinite(d.lon) &&
                    d.lat>=-90&&d.lat<=90 && d.lon>=-180&&d.lon<=180);

    const badge = document.getElementById("b-heat");
    if (badge) { badge.textContent = `parsed ${pts.length} points from scrubbed.csv`; badge.className = "badge"; }

    const spec = {
      $schema:'https://vega.github.io/schema/vega-lite/v5.json',
      width:1180, height:420,
      projection:{ type:'albersUsa' },
      layer:[
        { data:{ url:'https://vega.github.io/vega-datasets/data/us-10m.json',
                 format:{ type:'topojson', feature:'states' } },
          mark:{ type:'geoshape', fill:'#091120', stroke:'#1f2937' } },
        { data:{ values: pts },
          transform:[
            { bin:true, field:'lon', as:'bx' },
            { bin:true, field:'lat', as:'by' },
            { aggregate:[{op:'count', as:'n'}], groupby:['bx','by'] }
          ],
          mark:{ type:'rect', opacity:0.85 },
          encoding:{
            x:{ field:'bx', type:'quantitative', title:'Longitude' },
            y:{ field:'by', type:'quantitative', title:'Latitude' },
            color:{ field:'n', type:'quantitative', title:'Reports', scale:{ scheme:'blues' } }
          }
        }
      ],
      config:{ background:null }
    };
    vegaEmbed('#heat', spec, {actions:false});
  }catch(e){
    console.error('Heatmap error:', e);
    const badge = document.getElementById('b-heat');
    if (badge) { badge.textContent = 'failed to load'; badge.className = 'badge err'; }
  }
}

// 2) MONTHLY (line+area) — robust YYYY-MM parsing (works even if full dates are weird)
async function renderMonthly(){
  try{
    const {url,text} = await fetchFirst(PATHS.monthly);
    const rows = parseSemi(text);
    const values = rows.map(r=>{
      const ym = ymKey(r.month);
      const cnt = +String(r.count).replace(/[, ]/g,'');
      return ym ? { date:new Date(ym+'-01'), count:cnt } : null;
    }).filter(d => d && isFinite(d.count));

    setBadge("b-monthly", `loaded ${values.length} rows from ${url}`);
    const spec = {
      $schema:'https://vega.github.io/schema/vega-lite/v5.json',
      width: 560, height: 340,
      data: { values },
      layer:[
        { mark:{ type:'area', opacity:0.15, color:'#38bdf8' },
          encoding:{ x:{field:'date',type:'temporal',title:'Month'}, y:{field:'count',type:'quantitative',title:'Sightings'} } },
        { mark:{ type:'line', color:'#38bdf8' },
          encoding:{ x:{field:'date',type:'temporal'}, y:{field:'count',type:'quantitative'} } },
        { mark:{ type:'point', color:'#38bdf8' },
          encoding:{ x:{field:'date',type:'temporal'}, y:{field:'count',type:'quantitative'}, tooltip:[{field:'date',type:'temporal'},{field:'count',type:'quantitative'}] } }
      ]
    };
    return vegaEmbed('#monthly', spec, {actions:false});
  }catch(e){
    console.error('Monthly load error:', e);
    setBadge('b-monthly','failed to load', false);
  }
}

// 3) HOURLY (radial donut)
async function renderHourly(){
  try{
    const {url,text} = await fetchFirst(PATHS.hourly);
    const rows = parseSemi(text);
    const values = rows.map(r=>({ hour:+r.hour, count:+String(r.count).replace(/[, ]/g,'') }))
                       .filter(d=>isFinite(d.hour)&&isFinite(d.count));

    setBadge("b-hourly", `loaded ${values.length} rows from ${url}`);
    const spec = {
      $schema:'https://vega.github.io/schema/vega-lite/v5.json',
      width:560, height:340,
      data:{ values },
      transform:[ { calculate:'format(datum.hour, "02")', as:'hlabel' } ],
      mark:{ type:'arc', innerRadius:90, stroke:'#0b1220' },
      encoding:{
        theta:{ field:'count', type:'quantitative', stack:true, title:'Reports' },
        color:{ field:'hlabel', type:'nominal', legend:{title:'Hour (00–23)', orient:'bottom', columns:6, labelLimit:160} },
        tooltip:[ {field:'hour',title:'Hour'}, {field:'count',type:'quantitative'} ]
      },
      config:{ legend:{orient:'bottom'} }
    };
    return vegaEmbed('#hourly', spec, {actions:false});
  }catch(e){
    console.error('Hourly load error:', e);
    setBadge('b-hourly','failed to load', false);
  }
}

// 4) TOP CITIES (bar) — uses city;count (no lat/lon)
async function renderCities(){
  try{
    const {url,text} = await fetchFirst(PATHS.cities);
    const rows = parseSemi(text);
    const values = rows.map(r=>({ city:(r.city||'').toLowerCase().trim(), count:+String(r.count).replace(/[, ]/g,'') }))
                       .filter(r=>r.city && isFinite(r.count))
                       .sort((a,b)=>b.count-a.count)
                       .slice(0,30);

    setBadge("b-cities", `loaded ${values.length} rows from ${url}`);
    const spec = {
      $schema:'https://vega.github.io/schema/vega-lite/v5.json',
      width:560, height:340,
      data:{ values },
      mark:{ type:'bar', tooltip:true },
      encoding:{
        y:{ field:'city', type:'nominal', sort:'-x', title:'City' },
        x:{ field:'count', type:'quantitative', title:'Reports' }
      }
    };
    return vegaEmbed('#cities', spec, {actions:false});
  }catch(e){
    console.error('Cities load error:', e);
    setBadge('b-cities','failed to load', false);
  }
}

// 5) SHAPES (bar)
async function renderShapes(){
  try{
    const {url,text} = await fetchFirst(PATHS.shapes);
    const rows = parseSemi(text);
    const values = rows.map(r=>({ shape:(r.shape||'').toLowerCase().trim(), count:+String(r.count).replace(/[, ]/g,'') }))
                       .filter(r=>r.shape && isFinite(r.count));

    setBadge("b-shapes", `loaded ${values.length} rows from ${url}`);
    const spec = {
      $schema:'https://vega.github.io/schema/vega-lite/v5.json',
      width:560, height:340,
      data:{ values },
      mark:{ type:'bar', tooltip:true },
      encoding:{
        y:{ field:'shape', type:'nominal', sort:'-x', title:'Shape' },
        x:{ field:'count', type:'quantitative', title:'Reports' }
      }
    };
    return vegaEmbed('#shapes', spec, {actions:false});
  }catch(e){
    console.error('Shapes load error:', e);
    setBadge('b-shapes','failed to load', false);
  }
}

Promise.all([
  renderMap(),
  renderMonthly(),
  renderHourly(),
  renderCities(),
  renderShapes(),
  renderHeat()       // <-- add this
]);

